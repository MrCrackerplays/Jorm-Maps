<!DOCTYPE html>
<html lang="en">
<head>
	
	<title>Grid coordinates - Leaflet</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="icon.png" />

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
	<script src="./dist/hexagonalgrid.js"></script>

	<style>
		:root {
			--one: red;
			--two: blue;
		}

		.beppie {
			outline: 1px solid var(--one);
		}

		.beppoe {
			outline: 1px solid var(--two);
		}
		html, body {
			height: 100%;
			margin: 0;
		}
		.leaflet-container {
			height: 400px;
			width: 600px;
			max-width: 100%;
			max-height: 100%;
		}

		.hex {
			fill: none;
			stroke: black;
		}
	</style>

	
</head>
<body>

<div id='map'></div>
<!--svg definition which we don't want to show but so want to reuse-->
<!-- <div style="display:none;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="hex" viewBox="0 0 720 623.53829"><polygon class="hex" points="720,311.769145 540,623.53829 180,623.53829 0,311.769145 180,0 540,0"/></svg></div> -->
<script type="text/javascript">
	const METER_PER_MILE = 1609.344;
	const METER = 1;
	const MILE_PIXEL_MODIFIER = METER / METER_PER_MILE; //transform the default length (1 meter) of a single pixel to 1 mile
	const TARGET_PIXEL_LENGTH = 48; //how many pixels long we want our target to be
	const MILES_PER_TARGET = 48; //how many miles long we want our target to be
	//this means that at zoom level 0 our target of 24 miles will be 100 pixels long
	const SCALE_MODIFIER = TARGET_PIXEL_LENGTH * MILE_PIXEL_MODIFIER / MILES_PER_TARGET;
	L.CRS.dod = L.extend({}, L.CRS.Simple, {
		projection: L.extend( L.Projection.LonLat, {
			bounds: L.bounds([0, 0], [197756.19072 * 2, 197756.19072 * 2])
		}),
		transformation: new L.Transformation(SCALE_MODIFIER, 0, SCALE_MODIFIER, 0),
		// Changing the transformation is the key part, everything else is the same.
		// By specifying a factor, you specify what distance in meters one pixel occupies (as it still is CRS.Simple in all other regards).
		// In this case, I have a tile layer with 256px pieces, so Leaflet thinks it's only 256 meters wide.
		// I know the map is supposed to be 2048x2048 meters, so I specify a factor of 0.125 to multiply in both directions.
		// In the actual project, I compute all that from the gdal2tiles tilemapresources.xml, 
		// which gives the necessary information about tilesizes, total bounds and units-per-pixel at different levels.


		// Scale, zoom and distance are entirely unchanged from CRS.Simple
		scale: function (zoom) {
			return Math.pow(2, zoom);
		},

		zoom: function (scale) {
			return Math.log(scale) / Math.LN2;
		},

		distance: function (latlng1, latlng2) {
			var dx = latlng2.lng - latlng1.lng,
				dy = latlng2.lat - latlng1.lat;

			return Math.sqrt(dx * dx + dy * dy);
		},
		infinite: false
	});

	var map = L.map('map', {
		crs: L.CRS.dod,
		center: [0, 0],
		zoom: 0
	});

	function style(feature) {
		return {
			fillColor: 'transparent',
			weight: 1,
			opacity: 1,
			color: 'white',
			dashArray: '0',
			fillOpacity: 1
		};
	}

	function click(e) {
		popup = L.popup()
						.setLatLng(e.latlng)
						.setContent("Hexagon ID: "+e.target.feature.properties.id)
						.openOn(map);
	}

	function onEachFeature(feature, layer) {
		layer.on({
			click: click
		});
	}

	L.GridLayer.DebugCoords = L.GridLayer.extend({
		createTile: function (coords, done) {
			var tile = document.createElement("div");
			var text = document.createTextNode([coords.x, coords.y, coords.z].join(', '));
			tile.appendChild(text);

			var size = this.getTileSize;

			// tile.innerHTML =  + "<svg><use href=\"#hex\"></svg>";
			if ((coords.x + coords.y) % 2 == 0) {
				var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				var svgNameSpace = svg.namespaceURI;
				var use = document.createElementNS(svgNameSpace, "use");
				use.setAttributeNS(null, "href", "#hex");
				svg.appendChild(use);
				// tile.appendChild(svg);
				if (coords.x % 2 == 0)
				{
					tile.classList.add("beppie");
				}
				else
				{
					tile.classList.add("beppoe");
				}
			}

			setTimeout(function () {
				done(null, tile); // Syntax is 'done(error, tile)'
			}, 500 + Math.random() * 1500);

			return tile;
		}
	});
	const scale = L.control.scale({ updateWhenIdle: true }).addTo(map);
	
	L.gridLayer.debugCoords = function (opts) {
		return new L.GridLayer.DebugCoords(opts);
	};

	const hex_side_len = METER_PER_MILE * 24 / Math.sqrt(3);
	const world_width = map.options.crs.projection.bounds.max.x - map.options.crs.projection.bounds.min.x;
	const world_height = map.options.crs.projection.bounds.max.y - map.options.crs.projection.bounds.min.y;
	const columns = 1 + world_width / (hex_side_len * 1.5);
	const rows = 1 + world_height / (hex_side_len * Math.sqrt(3));
	const center_hex_0 = [map.options.crs.projection.bounds.min.x, map.options.crs.projection.bounds.min.y];

	var debugCoordsGrid = L.gridLayer.debugCoords({tileSize: 256});
	var testlayer = new L.TileLayer('jorm0.png', {tileSize: 256});
	var hexGrid = L.geoJson(H.hexagonalGrid(center_hex_0, columns, rows, hex_side_len), {
						style: style,
						onEachFeature: onEachFeature
	});

	map.addLayer(testlayer);
	map.addLayer(hexGrid);
	map.addLayer(debugCoordsGrid);
	console.log(map.distance(map.unproject([0, 0]), map.unproject([0, 100])) / METER_PER_MILE);
</script>
</body>
</html>
