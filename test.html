<!DOCTYPE html>
<html lang="en">
<head>
	
	<title>Grid coordinates - Leaflet</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<link rel="shortcut icon" type="image/x-icon" href="icon.png" />

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js" integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
	<script src="https://unpkg.com/leaflet.tilelayer.fallback@1.0.4/dist/leaflet.tilelayer.fallback.js"></script>
	<script src="./dist/hexagonalgrid.js"></script>

	<style>
		:root {
			--one: red;
			--two: blue;
		}

		.beppie {
			outline: 1px solid var(--one);
		}

		.beppoe {
			outline: 1px solid var(--two);
		}
		html, body {
			height: 100%;
			margin: 0;
		}
		.leaflet-container {
			height: 400px;
			width: 600px;
			max-width: 100%;
			max-height: 100%;
		}

		.hex {
			fill: none;
			stroke: black;
		}
	</style>

	
</head>
<body>
<div style="display: flex; justify-content: center; align-items: center;">
	<div id='map' style="outline: none;"></div>
</div>
<!--svg definition which we don't want to show but so want to reuse-->
<!-- <div style="display:none;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" id="hex" viewBox="0 0 720 623.53829"><polygon class="hex" points="720,311.769145 540,623.53829 180,623.53829 0,311.769145 180,0 540,0"/></svg></div> -->
<script type="text/javascript">
	// const MIN_TILE;
	const METER_PER_MILE = 1609.344;
	const METER_PER_FOOT = 0.3048;
	const METER = 1;
	const FOOT_PIXEL_MODIFIER = METER / METER_PER_FOOT; //transform the default length (1 meter) of a single pixel to 1 mile
	const TARGET_ZOOM = 22;
	const TWO_POW = Math.pow(2, TARGET_ZOOM);
	const TARGET_PIXEL_LENGTH = 256 / TWO_POW; //how many pixels long we want our target to be
	const FOOT_PER_TARGET = 5; //how many miles long we want our target to be
	//this means that at zoom level 22 our target of 5 feet will be 256 pixels long
	const SCALE_MODIFIER = TARGET_PIXEL_LENGTH * FOOT_PIXEL_MODIFIER / FOOT_PER_TARGET;
	L.CRS.dod = L.extend({}, L.CRS.Simple, {
		projection: L.extend( L.Projection.LonLat, {
			bounds: L.bounds([0, 0], [METER_PER_FOOT * 5 * TWO_POW , METER_PER_FOOT * 5 * TWO_POW])
		}),
		//have: zoom=0, 1tile=1m
		//have: zoom=20 1tile=1m/(2^20)
		//		zoom=20 1tile=1m/(2^20) * 2^20 -> 1tile=1m
		//		0.3048m=1ft		5ft=0.3048*5
		//		zoom=20 1tile=1m/(2^20) * 2^20 * 0.3048 * 5 -> 1tile=5ft
		//goal: zoom=20 1tile=5ft
		transformation: new L.Transformation(SCALE_MODIFIER, 0, SCALE_MODIFIER, 0),
		// Changing the transformation is the key part, everything else is the same.
		// By specifying a factor, you specify what distance in meters one pixel occupies (as it still is CRS.Simple in all other regards).
		// In this case, I have a tile layer with 256px pieces, so Leaflet thinks it's only 256 meters wide.
		// I know the map is supposed to be 2048x2048 meters, so I specify a factor of 0.125 to multiply in both directions.
		// In the actual project, I compute all that from the gdal2tiles tilemapresources.xml, 
		// which gives the necessary information about tilesizes, total bounds and units-per-pixel at different levels.


		// Scale, zoom and distance are entirely unchanged from CRS.Simple
		scale: function (zoom) {
			return Math.pow(2, zoom);
		},

		zoom: function (scale) {
			return Math.log(scale) / Math.LN2;
		},

		distance: function (latlng1, latlng2) {
			var dx = latlng2.lng - latlng1.lng,
				dy = latlng2.lat - latlng1.lat;

			return Math.sqrt(dx * dx + dy * dy);
		},
		infinite: false
	});

	var map = L.map('map', {
		crs: L.CRS.dod,
		center: [0, 0],
		preferCanvas: true,
		inertiaMaxSpeed: 3000,
		zoom: 2,
		maxBounds: [[-500000, -500000],[500000 + METER_PER_FOOT * 5 * TWO_POW, 500000 + METER_PER_FOOT * 5 * TWO_POW]],
		maxBoundsViscosity: 1.0
	});

	let oef = 1;
	function style(feature) {
		if (oef++ == 2)
			console.log(feature);
		return {
			fillColor: feature.properties.x == 20 ? 'rgb(255,0,0)' : 'transparent',
			weight: 1,
			opacity: 1,
			color: 'white',
			dashArray: '0',
			fillOpacity: feature.properties.x == 20 ? 0.5 : 1
		};
	}

	function highlightFeature(e) {
		var layer = e.target;

		layer.setStyle({
			weight: map.getZoom() == 2 ? 1 : 2,
			color: '#666',
			fillOpacity: 0.7
		});

		if (!L.Browser.ie && !L.Browser.opera) {
			layer.bringToFront();
		}
	}

	function resetHighlight(e) {
		hexGrid[0].resetStyle(e.target);
	}

	function click(e) {
		console.log(e.target)
		e.target.options.fillColor = "blue";
		e.target.options.fillOpacity = 0.5;
		popup = L.popup()
						.setLatLng(e.latlng)
						.setContent("Hexagon ID: "+e.target.feature.properties.id+"<br/>"+e.latlng)
						.openOn(map);
	}

	function onEachFeature(feature, layer) {
		layer.on({
			mouseover: highlightFeature,
			mouseout: resetHighlight,
			click: click
		});
	}

	L.GridLayer.DebugCoords = L.GridLayer.extend({
		createTile: function (coords, done) {
			var tile = document.createElement("div");
			var text = document.createTextNode([coords.x, coords.y, coords.z].join(', '));
			tile.appendChild(text);

			var size = this.getTileSize;

			if ((coords.x + coords.y) % 2 == 0) {
				var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				var svgNameSpace = svg.namespaceURI;
				var use = document.createElementNS(svgNameSpace, "use");
				use.setAttributeNS(null, "href", "#hex");
				svg.appendChild(use);
				// tile.appendChild(svg);
				if (coords.x % 2 == 0)
				{
					tile.classList.add("beppie");
				}
				else
				{
					tile.classList.add("beppoe");
				}
			}

			setTimeout(function () {
				done(null, tile); // Syntax is 'done(error, tile)'
			}, 500 + Math.random() * 1500);

			return tile;
		}
	});
	const scale = L.control.scale({ updateWhenIdle: true }).addTo(map);
	
	L.gridLayer.debugCoords = function (opts) {
		return new L.GridLayer.DebugCoords(opts);
	};
	var debugCoordsGrid = L.gridLayer.debugCoords({tileSize: 256, zIndex:100});

	var testimage = L.imageOverlay("SpireView.png", [[2779385.856,2697121.084 + 18726.912],[3611172.864,3657544.388 + 18726.912]],{
		opacity: 0.98,
		pane: 'tilePane'
	}).addTo(map);
	var townimage = L.imageOverlay("DodEstrin.jpg", [[2807524.992,3131905.344],[2823325.824,3154680.000]],{
		opacity: 0.98,
		pane: 'tilePane'
	});
	// var testlayer = L.tileLayer.fallback('jorma{z}.png', {
	// 	maxZoom: TARGET_ZOOM,
	// 	maxNativeZoom: TARGET_ZOOM,
	// 	tileSize: 256});

	const ROOT_3 = Math.sqrt(3);
	const hex_side_len = METER_PER_MILE * 24 / ROOT_3;
	const world_width = map.options.crs.projection.bounds.max.x - map.options.crs.projection.bounds.min.x;
	const world_height = map.options.crs.projection.bounds.max.y - map.options.crs.projection.bounds.min.y;
	const total_columns = Math.ceil(world_width / (hex_side_len * 1.5));
	const total_rows = Math.ceil(world_height / (hex_side_len * ROOT_3));
	console.log("cols", total_columns, "rows", total_rows);
	// const total_columns = 2;
	// const total_rows = 2;
	const cluster_size = 8;
	const cluster_columns = total_columns < cluster_size * 2 ? 1 : cluster_size;
	const cluster_rows = total_rows < cluster_size * 2 ? 1 : cluster_size;
	const columns = Math.floor(total_columns / cluster_columns);
	const rows = Math.floor(total_rows / cluster_rows);
	const center_hex_0 = [map.options.crs.projection.bounds.min.x, map.options.crs.projection.bounds.min.y];
	var hexGrid = [];
	for (let i = 0; i < cluster_columns; i++) {
		const local_columns = i == cluster_size - 1 ? columns + (total_columns % cluster_columns) : columns;
		for (let j = 0; j < cluster_rows; j++) {
			const local_rows = j == cluster_size - 1 ? rows + (total_rows % cluster_rows) : rows;
			// console.log("j", j, "i", i, "dingle", j + i * cluster_rows);
			hexGrid[j + i * cluster_rows] = L.geoJson(H.hexagonalGrid([center_hex_0[0] + (i * columns * 1.5 * hex_side_len),
								center_hex_0[1] + (j * rows * ROOT_3 * hex_side_len)],
							local_columns, local_rows, hex_side_len, columns * i, rows * j), {
								style: style,
								onEachFeature: onEachFeature
			});
		}
	}

	// hexGrid[0] = L.geoJson(H.hexagonalGrid(center_hex_0, columns, rows, hex_side_len), {
	// 					style: style,
	// 					onEachFeature: onEachFeature
	// });

	let call = undefined;
	let grid_holder = L.layerGroup();
	function onMove() {
		clearTimeout(call);
		map.removeLayer(grid_holder);
		call = setTimeout(function () {
			updateGrid();
			if (map.getZoom() >= 2 && map.getZoom() < 8)
				map.addLayer(grid_holder);
		}, 650);
	}
	function updateGrid() {
		if (map.getZoom() >= 7) {
			if (map.hasLayer(townimage) == false)
				map.addLayer(townimage);
		} else if (map.hasLayer(townimage)) {
			map.removeLayer(townimage);
		}
		if (map.getZoom() >= 2 && map.getZoom() < 8) {
			for (let i = 0; i < cluster_columns * cluster_rows; i++) {
				if (map.getBounds().intersects(hexGrid[i].getBounds())) {
					if (grid_holder.hasLayer(hexGrid[i]) == false) grid_holder.addLayer(hexGrid[i]);
				} else
					if (grid_holder.hasLayer(hexGrid[i])) grid_holder.removeLayer(hexGrid[i]);
			}
		}
	}

	// map.addLayer(testlayer);
	updateGrid();
	map.addLayer(debugCoordsGrid);
	map.addLayer(grid_holder);
	map.on('move', onMove);
	map.on('click', function(e) {
		console.log("Lat, Lon : " + e.latlng.lat + ", " + e.latlng.lng)
	});
	console.log(map.distance(map.unproject([0, 0]), map.unproject([0, 100])) / METER_PER_FOOT);
</script>
</body>
</html>
